<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Save the Date - Puzzle</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-touch-callout: none;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: #ffffff;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            touch-action: none;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #background-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 0;
            pointer-events: none;
        }

        #bg-img {
            display: block;
            width: 100%;
            height: auto;
        }

        #game-ui {
            text-align: center;
            padding: 15px 10px;
            z-index: 50;
        }

        h1 {
            font-size: 1.1rem;
            font-weight: 400;
            margin: 0;
            opacity: 0.8;
            color: #333;
            line-height: 1.4;
        }

        .instruction-highlight {
            font-weight: 600;
            color: #dfa668;
        }

        #puzzle-container {
            position: relative;
            z-index: 50;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            /* Taille fixe : 320x240 (ratio 4:3) - parfait pour mobile */
            width: 320px;
            height: 240px;
        }

        /* Tablette / Desktop */
        @media (min-width: 500px) {
            #puzzle-container {
                width: 480px;
                height: 360px;
            }
        }

        @media (min-width: 700px) {
            #puzzle-container {
                width: 560px;
                height: 420px;
            }
        }

        #puzzle-guide {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: url('guide.jpg') no-repeat center/100% 100%;
            opacity: 0.25;
            border: 2px dashed #ccc;
            border-radius: 8px;
            z-index: 0;
            filter: blur(4px);
        }

        #final-reveal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: url('puzzle.png') no-repeat center/100% 100%;
            opacity: 0;
            z-index: 150;
            transition: opacity 1.5s ease-in-out;
            pointer-events: none;
            border-radius: 8px;
        }

        .piece {
            position: absolute;
            cursor: grab;
            z-index: 60;
            touch-action: none;
        }

        .piece.dragging {
            z-index: 999;
            cursor: grabbing;
            filter: drop-shadow(0 8px 16px rgba(0,0,0,0.35));
        }

        .piece.locked {
            z-index: 100;
            cursor: default;
            pointer-events: none;
        }

        #success-message {
            position: fixed;
            bottom: -150px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 20px 25px;
            border-radius: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: calc(100% - 40px);
            max-width: 380px;
            z-index: 1000;
        }

        #success-message.visible {
            bottom: max(25px, env(safe-area-inset-bottom));
            opacity: 1;
        }

        #success-message h2 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.3rem;
        }

        #success-message p {
            margin: 0;
            color: #7f8c8d;
            font-size: 0.95rem;
        }

        .puzzle-complete #final-reveal { opacity: 1; }
        .puzzle-complete #puzzle-guide { opacity: 0; }
        .puzzle-complete { box-shadow: 0 15px 40px rgba(0,0,0,0.2); }
    </style>
</head>
<body>
    <div id="background-container">
        <img id="bg-img" src="bg.jpg" alt="">
    </div>

    <div id="game-ui">
        <h1>Assemblez les pi√®ces pour d√©couvrir<br><span class="instruction-highlight">la date du mariage</span></h1>
    </div>

    <div id="puzzle-container">
        <div id="puzzle-guide"></div>
        <div id="final-reveal"></div>
    </div>

    <div id="success-message">
        <h2>F√©licitations !</h2>
        <p>Vous avez maintenant la date du mariage ! H√¢te de vous y voir ü•∞</p>
    </div>

    <script>
        // Configuration fixe pour cette image (2048x1536, ratio 4:3)
        const CONFIG = {
            rows: 3,
            cols: 4,
            imgWidth: 2048,
            imgHeight: 1536,
            tabPercent: 0.20
        };

        const container = document.getElementById('puzzle-container');
        const successMsg = document.getElementById('success-message');

        let pieces = [];
        let piecesData = [];
        let lockedCount = 0;
        const totalPieces = CONFIG.rows * CONFIG.cols;
        let shapes = null;

        // Charger l'image
        const img = new Image();
        img.src = 'guide.jpg';
        img.onload = init;

        function init() {
            // G√©n√©rer les formes une seule fois
            shapes = generateShapes();

            // Initialiser les donn√©es
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    piecesData.push({
                        row: r,
                        col: c,
                        shape: shapes[r * CONFIG.cols + c],
                        locked: false,
                        x: 0,
                        y: 0
                    });
                }
            }

            createPieces();
            scramble();
        }

        function generateShapes() {
            const s = [];
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    let top = 0, right = 0, bottom = 0, left = 0;
                    if (r > 0) top = -s[(r-1) * CONFIG.cols + c][2];
                    if (c < CONFIG.cols - 1) right = Math.random() > 0.5 ? 1 : -1;
                    if (r < CONFIG.rows - 1) bottom = Math.random() > 0.5 ? 1 : -1;
                    if (c > 0) left = -s[r * CONFIG.cols + (c-1)][1];
                    s.push([top, right, bottom, left]);
                }
            }
            return s;
        }

        function createPieces() {
            // Supprimer les anciennes
            pieces.forEach(p => p.remove());
            pieces = [];

            // Dimensions du conteneur
            const cw = container.offsetWidth;
            const ch = container.offsetHeight;

            // Taille d'une pi√®ce de base (sans tab)
            const pieceW = cw / CONFIG.cols;
            const pieceH = ch / CONFIG.rows;
            const tabSize = Math.min(pieceW, pieceH) * CONFIG.tabPercent;

            // Taille totale avec tabs
            const totalW = pieceW + tabSize * 2;
            const totalH = pieceH + tabSize * 2;

            // Scale pour dessiner depuis l'image source
            const scaleX = CONFIG.imgWidth / cw;
            const scaleY = CONFIG.imgHeight / ch;

            for (let i = 0; i < piecesData.length; i++) {
                const d = piecesData[i];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = totalW;
                canvas.height = totalH;
                canvas.className = 'piece';
                if (d.locked) canvas.classList.add('locked');

                // M√©thode alternative pour iOS : utiliser destination-in au lieu de clip()
                // √âtape 1: Dessiner l'image compl√®te
                const srcX = (d.col * pieceW - tabSize) * scaleX;
                const srcY = (d.row * pieceH - tabSize) * scaleY;
                const srcW = totalW * scaleX;
                const srcH = totalH * scaleY;
                ctx.drawImage(img, srcX, srcY, srcW, srcH, 0, 0, totalW, totalH);

                // √âtape 2: Utiliser destination-in pour masquer avec la forme
                ctx.globalCompositeOperation = 'destination-in';
                ctx.beginPath();

                let x = tabSize, y = tabSize;
                ctx.moveTo(x, y);

                // Top
                if (d.shape[0] !== 0) drawTab(ctx, x, y, pieceW, 0, d.shape[0] * tabSize);
                else ctx.lineTo(x + pieceW, y);
                x += pieceW;

                // Right
                if (d.shape[1] !== 0) drawTab(ctx, x, y, 0, pieceH, d.shape[1] * tabSize);
                else ctx.lineTo(x, y + pieceH);
                y += pieceH;

                // Bottom
                if (d.shape[2] !== 0) drawTab(ctx, x, y, -pieceW, 0, d.shape[2] * tabSize);
                else ctx.lineTo(x - pieceW, y);
                x -= pieceW;

                // Left
                if (d.shape[3] !== 0) drawTab(ctx, x, y, 0, -pieceH, d.shape[3] * tabSize);
                else ctx.lineTo(x, y - pieceH);

                ctx.closePath();
                ctx.fill();

                // √âtape 3: Remettre le mode normal et dessiner les contours
                ctx.globalCompositeOperation = 'source-over';

                // Re-tracer le path pour les contours
                ctx.beginPath();
                x = tabSize; y = tabSize;
                ctx.moveTo(x, y);
                if (d.shape[0] !== 0) drawTab(ctx, x, y, pieceW, 0, d.shape[0] * tabSize);
                else ctx.lineTo(x + pieceW, y);
                x += pieceW;
                if (d.shape[1] !== 0) drawTab(ctx, x, y, 0, pieceH, d.shape[1] * tabSize);
                else ctx.lineTo(x, y + pieceH);
                y += pieceH;
                if (d.shape[2] !== 0) drawTab(ctx, x, y, -pieceW, 0, d.shape[2] * tabSize);
                else ctx.lineTo(x - pieceW, y);
                x -= pieceW;
                if (d.shape[3] !== 0) drawTab(ctx, x, y, 0, -pieceH, d.shape[3] * tabSize);
                else ctx.lineTo(x, y - pieceH);
                ctx.closePath();

                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Position
                if (d.locked) {
                    canvas.style.left = (d.col * pieceW - tabSize) + 'px';
                    canvas.style.top = (d.row * pieceH - tabSize) + 'px';
                } else {
                    canvas.style.left = d.x + 'px';
                    canvas.style.top = d.y + 'px';
                }

                canvas.dataset.index = i;
                addDrag(canvas, i, pieceW, pieceH, tabSize);
                container.appendChild(canvas);
                pieces.push(canvas);
            }
        }

        function drawTab(ctx, x, y, dx, dy, size) {
            const len = Math.sqrt(dx*dx + dy*dy);
            const neck = len * 0.35;
            const ux = dx/len, uy = dy/len;
            const nx = -uy, ny = ux;
            const sign = size > 0 ? 1 : -1;
            const h = Math.abs(size);

            const x1 = x + ux*(len-neck)/2, y1 = y + uy*(len-neck)/2;
            const x2 = x + ux*(len+neck)/2, y2 = y + uy*(len+neck)/2;

            ctx.lineTo(x1, y1);

            const cx1 = x1 + nx*sign*h*0.2, cy1 = y1 + ny*sign*h*0.2;
            const tx1 = x + ux*(len/2-neck*0.5) + nx*sign*h;
            const ty1 = y + uy*(len/2-neck*0.5) + ny*sign*h;
            const mx = x + ux*len/2 + nx*sign*h;
            const my = y + uy*len/2 + ny*sign*h;
            const tx2 = x + ux*(len/2+neck*0.5) + nx*sign*h;
            const ty2 = y + uy*(len/2+neck*0.5) + ny*sign*h;
            const cx2 = x2 + nx*sign*h*0.2, cy2 = y2 + ny*sign*h*0.2;

            ctx.bezierCurveTo(cx1, cy1, tx1, ty1, mx, my);
            ctx.bezierCurveTo(tx2, ty2, cx2, cy2, x2, y2);
            ctx.lineTo(x + dx, y + dy);
        }

        function scramble() {
            const rect = container.getBoundingClientRect();
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const header = document.getElementById('game-ui').offsetHeight + 10;

            pieces.forEach((p, i) => {
                if (piecesData[i].locked) return;

                const pw = p.width, ph = p.height;
                let x, y;

                // Zones: bas, gauche, droite
                const zones = [];

                // Bas
                if (winH - rect.bottom > ph + 30) {
                    zones.push(() => {
                        x = 10 + Math.random() * (winW - pw - 20);
                        y = rect.bottom + 10 + Math.random() * (winH - rect.bottom - ph - 20);
                    });
                }

                // Gauche
                if (rect.left > pw + 30) {
                    zones.push(() => {
                        x = 10 + Math.random() * (rect.left - pw - 20);
                        y = header + Math.random() * (winH - header - ph - 10);
                    });
                }

                // Droite
                if (winW - rect.right > pw + 30) {
                    zones.push(() => {
                        x = rect.right + 10 + Math.random() * (winW - rect.right - pw - 20);
                        y = header + Math.random() * (winH - header - ph - 10);
                    });
                }

                // Fallback
                if (zones.length === 0) {
                    x = 10 + Math.random() * (winW - pw - 20);
                    y = header + Math.random() * (winH - header - ph - 20);
                } else {
                    zones[Math.floor(Math.random() * zones.length)]();
                }

                // Convertir en position relative au conteneur
                const relX = x - rect.left;
                const relY = y - rect.top;

                p.style.left = relX + 'px';
                p.style.top = relY + 'px';
                piecesData[i].x = relX;
                piecesData[i].y = relY;
            });
        }

        function addDrag(el, index, pieceW, pieceH, tabSize) {
            let startX, startY, initLeft, initTop;
            let dragging = false;

            const start = (e) => {
                if (piecesData[index].locked) return;
                e.preventDefault();
                dragging = true;
                el.classList.add('dragging');

                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;
                initLeft = el.offsetLeft;
                initTop = el.offsetTop;
            };

            const move = (e) => {
                if (!dragging) return;
                e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                el.style.left = (initLeft + touch.clientX - startX) + 'px';
                el.style.top = (initTop + touch.clientY - startY) + 'px';
            };

            const end = () => {
                if (!dragging) return;
                dragging = false;
                el.classList.remove('dragging');

                // Check snap
                const d = piecesData[index];
                const targetX = d.col * pieceW - tabSize;
                const targetY = d.row * pieceH - tabSize;
                const curX = el.offsetLeft;
                const curY = el.offsetTop;

                const dist = Math.sqrt((curX-targetX)**2 + (curY-targetY)**2);
                const threshold = Math.max(25, pieceW * 0.3);

                if (dist < threshold) {
                    // Snap!
                    el.style.left = targetX + 'px';
                    el.style.top = targetY + 'px';
                    el.classList.add('locked');
                    d.locked = true;
                    lockedCount++;

                    if (lockedCount === totalPieces) win();
                } else {
                    // Sauvegarder position
                    d.x = el.offsetLeft;
                    d.y = el.offsetTop;
                }
            };

            el.addEventListener('mousedown', start);
            el.addEventListener('touchstart', start, {passive: false});
            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        function win() {
            container.classList.add('puzzle-complete');
            document.getElementById('game-ui').style.opacity = '0';

            setTimeout(() => {
                successMsg.classList.add('visible');
                confetti({
                    particleCount: 150,
                    spread: 70,
                    origin: { y: 0.9 },
                    colors: ['#ff718d', '#fdb44b', '#29cdff', '#e0c097']
                });
            }, 500);
        }

        // Resize: recr√©er les pi√®ces
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                createPieces();
                // Re-scramble les pi√®ces non lock√©es
                scramble();
            }, 200);
        });

        // Emp√™cher zoom iOS
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#puzzle-container')) e.preventDefault();
        }, {passive: false});

        let lastTap = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) e.preventDefault();
            lastTap = now;
        }, {passive: false});
    </script>
</body>
</html>
