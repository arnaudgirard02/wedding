<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Save the Date - Puzzle</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        html, body {
            margin: 0;
            padding: 0;
            min-height: 100%;
            background-color: #ffffff;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            touch-action: none;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #background-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: -1;
            pointer-events: none;
        }

        #bg-img {
            display: block;
            width: 100%;
            height: auto;
        }

        #game-ui {
            text-align: center;
            padding: 15px 10px;
            z-index: 50;
        }

        h1 {
            font-size: 1.1rem;
            font-weight: 400;
            margin: 0;
            opacity: 0.8;
            color: #333;
            line-height: 1.4;
        }

        .instruction-highlight {
            font-weight: 600;
            color: #dfa668;
        }

        #puzzle-container {
            position: relative;
            z-index: 50;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            width: 240px;
            height: 180px;
            overflow: visible;
        }

        @media (min-width: 360px) {
            #puzzle-container {
                width: 300px;
                height: 225px;
            }
        }

        @media (min-width: 450px) {
            #puzzle-container {
                width: 320px;
                height: 240px;
            }
        }

        @media (min-width: 500px) {
            #puzzle-container {
                width: 480px;
                height: 360px;
            }
        }

        @media (min-width: 700px) {
            #puzzle-container {
                width: 560px;
                height: 420px;
            }
        }

        #puzzle-guide {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: url('guide.jpg') no-repeat center/100% 100%;
            opacity: 0.25;
            border: 2px dashed #ccc;
            border-radius: 8px;
            z-index: 0;
            filter: blur(4px);
        }

        #final-reveal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: url('puzzle.png') no-repeat center/100% 100%;
            opacity: 0;
            z-index: 150;
            transition: opacity 1.5s ease-in-out;
            pointer-events: none;
            border-radius: 8px;
        }

        /* Pièces en DIV avec background-image et clip-path */
        .piece {
            cursor: grab;
            touch-action: none;
            background-image: url('guide.jpg');
            background-repeat: no-repeat;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .piece.dragging {
            position: fixed;
            z-index: 9999;
            cursor: grabbing;
            filter: drop-shadow(0 8px 16px rgba(0,0,0,0.35));
        }

        .piece.locked {
            position: absolute;
            z-index: 300;
            cursor: default;
            pointer-events: none;
        }

        #success-message {
            position: fixed;
            bottom: -150px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 20px 25px;
            border-radius: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: calc(100% - 40px);
            max-width: 380px;
            z-index: 1000;
        }

        #success-message.visible {
            bottom: max(25px, env(safe-area-inset-bottom));
            opacity: 1;
        }

        #success-message h2 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.3rem;
        }

        #success-message p {
            margin: 0 0 15px 0;
            color: #7f8c8d;
            font-size: 0.95rem;
        }

        .btn-form {
            display: inline-block;
            padding: 12px 30px;
            background-color: #dfa668;
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(223, 166, 104, 0.3);
        }

        .btn-form:hover {
            background-color: #c98f52;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(223, 166, 104, 0.4);
        }

        .btn-form:active {
            transform: translateY(0);
        }

        #pieces-tray {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 5px;
            z-index: 100;
            margin-top: 15px;
        }

        .puzzle-complete #final-reveal { opacity: 1; }
        .puzzle-complete #puzzle-guide { opacity: 0; }
        .puzzle-complete .piece { opacity: 0; }
        .puzzle-complete { box-shadow: 0 15px 40px rgba(0,0,0,0.2); }
        .puzzle-complete ~ #pieces-tray { display: none; }
    </style>
</head>
<body>
    <div id="background-container">
        <img id="bg-img" src="bg.jpg" alt="">
    </div>

    <div id="game-ui">
        <h1>Assemblez les pièces pour découvrir<br><span class="instruction-highlight">la date du mariage</span></h1>
    </div>

    <div id="puzzle-container">
        <div id="puzzle-guide"></div>
        <div id="final-reveal"></div>
    </div>

    <div id="pieces-tray"></div>

    <div id="success-message">
        <h2>Félicitations !</h2>
        <p>Le mariage aura lieu au Tir au Vol, à Arcachon ⚓️</p>
        <a href="https://tally.so/r/Gxl9qj" class="btn-form">Continuer</a>
    </div>

    <script>
        const CONFIG = {
            rows: 3,
            cols: 4,
            tabPercent: 0.18
        };

        const container = document.getElementById('puzzle-container');
        const piecesTray = document.getElementById('pieces-tray');
        const successMsg = document.getElementById('success-message');

        let pieces = [];
        let piecesData = [];
        let lockedCount = 0;
        const totalPieces = CONFIG.rows * CONFIG.cols;

        // Formes des tabs (générées une fois)
        // 0 = bord plat, 1 = tab sortant, -1 = tab rentrant
        // [top, right, bottom, left]
        const shapes = generateShapes();

        function generateShapes() {
            const s = [];
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    let top = 0, right = 0, bottom = 0, left = 0;
                    if (r > 0) top = -s[(r-1) * CONFIG.cols + c][2];
                    if (c < CONFIG.cols - 1) right = Math.random() > 0.5 ? 1 : -1;
                    if (r < CONFIG.rows - 1) bottom = Math.random() > 0.5 ? 1 : -1;
                    if (c > 0) left = -s[r * CONFIG.cols + (c-1)][1];
                    s.push([top, right, bottom, left]);
                }
            }
            return s;
        }

        // Initialiser les données des pièces
        for (let r = 0; r < CONFIG.rows; r++) {
            for (let c = 0; c < CONFIG.cols; c++) {
                piecesData.push({
                    row: r,
                    col: c,
                    shape: shapes[r * CONFIG.cols + c],
                    locked: false,
                    x: 0,
                    y: 0
                });
            }
        }

        // Créer les pièces
        createPieces();

        function createPieces() {
            pieces.forEach(p => p.remove());
            pieces = [];

            const cw = container.offsetWidth;
            const ch = container.offsetHeight;
            const pieceW = cw / CONFIG.cols;
            const pieceH = ch / CONFIG.rows;
            const tabSize = Math.min(pieceW, pieceH) * CONFIG.tabPercent;

            // Mélanger l'ordre pour l'affichage dans le tray
            const shuffledIndices = piecesData.map((_, i) => i);
            for (let i = shuffledIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledIndices[i], shuffledIndices[j]] = [shuffledIndices[j], shuffledIndices[i]];
            }

            shuffledIndices.forEach(i => {
                const d = piecesData[i];
                const piece = document.createElement('div');
                piece.className = 'piece';

                // Taille de la pièce (avec espace pour les tabs)
                const totalW = pieceW + tabSize * 2;
                const totalH = pieceH + tabSize * 2;

                piece.style.width = totalW + 'px';
                piece.style.height = totalH + 'px';

                // Position du background pour montrer la bonne partie de l'image
                const bgX = -(d.col * pieceW - tabSize);
                const bgY = -(d.row * pieceH - tabSize);
                piece.style.backgroundPosition = `${bgX}px ${bgY}px`;
                piece.style.backgroundSize = `${cw}px ${ch}px`;

                // Générer le clip-path SVG pour la forme de la pièce
                const clipPath = generateClipPath(d.shape, pieceW, pieceH, tabSize, totalW, totalH);
                piece.style.clipPath = clipPath;
                piece.style.webkitClipPath = clipPath;

                piece.dataset.index = i;
                addDrag(piece, i, pieceW, pieceH, tabSize);

                // Les pièces lockées vont dans le container, les autres dans le tray
                if (d.locked) {
                    piece.classList.add('locked');
                    piece.style.left = (d.col * pieceW - tabSize) + 'px';
                    piece.style.top = (d.row * pieceH - tabSize) + 'px';
                    container.appendChild(piece);
                } else {
                    piecesTray.appendChild(piece);
                }
                pieces[i] = piece;
            });
        }

        function generateClipPath(shape, pieceW, pieceH, tabSize, totalW, totalH) {
            const toPctX = (x) => (x / totalW * 100).toFixed(2);
            const toPctY = (y) => (y / totalH * 100).toFixed(2);

            // Fonction pour générer des points sur une courbe de Bézier cubique
            function bezierPoints(p0, p1, p2, p3, numPoints) {
                const points = [];
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    const mt = 1 - t;
                    const mt2 = mt * mt;
                    const mt3 = mt2 * mt;

                    const x = mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x;
                    const y = mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y;
                    points.push({ x, y });
                }
                return points;
            }

            const pathPoints = [];
            let x = tabSize;
            let y = tabSize;

            // --- TOP EDGE ---
            if (shape[0] === 0) {
                pathPoints.push(`${toPctX(x)}% ${toPctY(y)}%`);
                pathPoints.push(`${toPctX(x + pieceW)}% ${toPctY(y)}%`);
            } else {
                const dir = shape[0];
                const tabH = tabSize;
                const neckW = pieceW * 0.28;
                const bulgeW = pieceW * 0.34;
                const centerX = x + pieceW / 2;
                const neckStart = centerX - neckW / 2;
                const neckEnd = centerX + neckW / 2;
                const tabTip = dir > 0 ? y - tabH : y + tabH;

                pathPoints.push(`${toPctX(x)}% ${toPctY(y)}%`);
                pathPoints.push(`${toPctX(neckStart)}% ${toPctY(y)}%`);

                // Courbe gauche du tab (neck vers bulge)
                const curve1 = bezierPoints(
                    { x: neckStart, y: y },
                    { x: neckStart, y: tabTip + (y - tabTip) * 0.4 },
                    { x: centerX - bulgeW / 2, y: tabTip },
                    { x: centerX, y: tabTip },
                    8
                );
                curve1.forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                // Courbe droite du tab (bulge vers neck)
                const curve2 = bezierPoints(
                    { x: centerX, y: tabTip },
                    { x: centerX + bulgeW / 2, y: tabTip },
                    { x: neckEnd, y: tabTip + (y - tabTip) * 0.4 },
                    { x: neckEnd, y: y },
                    8
                );
                curve2.slice(1).forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                pathPoints.push(`${toPctX(x + pieceW)}% ${toPctY(y)}%`);
            }
            x += pieceW;

            // --- RIGHT EDGE ---
            if (shape[1] === 0) {
                pathPoints.push(`${toPctX(x)}% ${toPctY(y + pieceH)}%`);
            } else {
                const dir = shape[1];
                const tabW = tabSize;
                const neckH = pieceH * 0.28;
                const bulgeH = pieceH * 0.34;
                const centerY = y + pieceH / 2;
                const neckStart = centerY - neckH / 2;
                const neckEnd = centerY + neckH / 2;
                const tabTip = dir > 0 ? x + tabW : x - tabW;

                pathPoints.push(`${toPctX(x)}% ${toPctY(neckStart)}%`);

                const curve1 = bezierPoints(
                    { x: x, y: neckStart },
                    { x: tabTip - (tabTip - x) * 0.4, y: neckStart },
                    { x: tabTip, y: centerY - bulgeH / 2 },
                    { x: tabTip, y: centerY },
                    8
                );
                curve1.forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                const curve2 = bezierPoints(
                    { x: tabTip, y: centerY },
                    { x: tabTip, y: centerY + bulgeH / 2 },
                    { x: tabTip - (tabTip - x) * 0.4, y: neckEnd },
                    { x: x, y: neckEnd },
                    8
                );
                curve2.slice(1).forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                pathPoints.push(`${toPctX(x)}% ${toPctY(y + pieceH)}%`);
            }
            y += pieceH;

            // --- BOTTOM EDGE ---
            if (shape[2] === 0) {
                pathPoints.push(`${toPctX(x - pieceW)}% ${toPctY(y)}%`);
            } else {
                const dir = shape[2];
                const tabH = tabSize;
                const neckW = pieceW * 0.28;
                const bulgeW = pieceW * 0.34;
                const centerX = x - pieceW / 2;
                const neckEnd = centerX + neckW / 2;
                const neckStart = centerX - neckW / 2;
                const tabTip = dir > 0 ? y + tabH : y - tabH;

                pathPoints.push(`${toPctX(neckEnd)}% ${toPctY(y)}%`);

                const curve1 = bezierPoints(
                    { x: neckEnd, y: y },
                    { x: neckEnd, y: tabTip - (tabTip - y) * 0.4 },
                    { x: centerX + bulgeW / 2, y: tabTip },
                    { x: centerX, y: tabTip },
                    8
                );
                curve1.forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                const curve2 = bezierPoints(
                    { x: centerX, y: tabTip },
                    { x: centerX - bulgeW / 2, y: tabTip },
                    { x: neckStart, y: tabTip - (tabTip - y) * 0.4 },
                    { x: neckStart, y: y },
                    8
                );
                curve2.slice(1).forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                pathPoints.push(`${toPctX(x - pieceW)}% ${toPctY(y)}%`);
            }
            x -= pieceW;

            // --- LEFT EDGE ---
            if (shape[3] === 0) {
                // Fermeture implicite
            } else {
                const dir = shape[3];
                const tabW = tabSize;
                const neckH = pieceH * 0.28;
                const bulgeH = pieceH * 0.34;
                const centerY = y - pieceH / 2;
                const neckEnd = centerY + neckH / 2;
                const neckStart = centerY - neckH / 2;
                const tabTip = dir > 0 ? x - tabW : x + tabW;

                pathPoints.push(`${toPctX(x)}% ${toPctY(neckEnd)}%`);

                const curve1 = bezierPoints(
                    { x: x, y: neckEnd },
                    { x: tabTip + (x - tabTip) * 0.4, y: neckEnd },
                    { x: tabTip, y: centerY + bulgeH / 2 },
                    { x: tabTip, y: centerY },
                    8
                );
                curve1.forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                const curve2 = bezierPoints(
                    { x: tabTip, y: centerY },
                    { x: tabTip, y: centerY - bulgeH / 2 },
                    { x: tabTip + (x - tabTip) * 0.4, y: neckStart },
                    { x: x, y: neckStart },
                    8
                );
                curve2.slice(1).forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));
            }

            return `polygon(${pathPoints.join(', ')})`;
        }

        function addDrag(el, index, pieceW, pieceH, tabSize) {
            let startX, startY, startLeft, startTop;
            let dragging = false;

            const start = (e) => {
                if (piecesData[index].locked) return;
                e.preventDefault();
                dragging = true;

                const touch = e.touches ? e.touches[0] : e;
                const rect = el.getBoundingClientRect();

                // Passer en position fixed pour le drag
                el.style.position = 'fixed';
                el.style.left = rect.left + 'px';
                el.style.top = rect.top + 'px';
                el.classList.add('dragging');

                // Déplacer dans le body pour éviter les problèmes de z-index
                document.body.appendChild(el);

                startX = touch.clientX;
                startY = touch.clientY;
                startLeft = rect.left;
                startTop = rect.top;
            };

            const move = (e) => {
                if (!dragging) return;
                e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                el.style.left = (startLeft + touch.clientX - startX) + 'px';
                el.style.top = (startTop + touch.clientY - startY) + 'px';
            };

            const end = () => {
                if (!dragging) return;
                dragging = false;
                el.classList.remove('dragging');

                const d = piecesData[index];
                const containerRect = container.getBoundingClientRect();
                const elRect = el.getBoundingClientRect();

                // Position cible dans le container
                const targetX = d.col * pieceW - tabSize;
                const targetY = d.row * pieceH - tabSize;

                // Position actuelle relative au container
                const curX = elRect.left - containerRect.left;
                const curY = elRect.top - containerRect.top;

                const dist = Math.sqrt((curX - targetX) ** 2 + (curY - targetY) ** 2);
                const threshold = Math.max(25, pieceW * 0.3);

                if (dist < threshold) {
                    // Locker la pièce dans le container
                    el.style.position = 'absolute';
                    el.style.left = targetX + 'px';
                    el.style.top = targetY + 'px';
                    el.classList.add('locked');
                    container.appendChild(el);
                    d.locked = true;
                    lockedCount++;

                    if (lockedCount === totalPieces) win();
                } else {
                    // Remettre dans le tray
                    el.style.position = '';
                    el.style.left = '';
                    el.style.top = '';
                    piecesTray.appendChild(el);
                }
            };

            el.addEventListener('mousedown', start);
            el.addEventListener('touchstart', start, {passive: false});
            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        function win() {
            container.classList.add('puzzle-complete');
            document.getElementById('game-ui').style.opacity = '0';

            setTimeout(() => {
                successMsg.classList.add('visible');
                confetti({
                    particleCount: 150,
                    spread: 70,
                    origin: { y: 0.9 },
                    colors: ['#ff718d', '#fdb44b', '#29cdff', '#e0c097']
                });
            }, 500);
        }

        // Resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                // Reset et recréer les pièces
                piecesData.forEach(d => d.locked = false);
                lockedCount = 0;
                container.classList.remove('puzzle-complete');
                createPieces();
            }, 200);
        });

        // Empêcher zoom iOS
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#puzzle-container')) e.preventDefault();
        }, {passive: false});

        let lastTap = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) e.preventDefault();
            lastTap = now;
        }, {passive: false});
    </script>
</body>
</html>
