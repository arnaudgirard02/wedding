<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Save the Date - Puzzle</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; padding: 0; background-color: #ffffff; color: #333; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow: hidden; }

        #background-container { position: fixed; bottom: 0; left: 0; width: 100%; z-index: 0; pointer-events: none; }
        #bg-img { width: 100%; height: auto; display: block; }

        #game-ui { text-align: center; margin-top: 20px; z-index: 50; width: 90%; }
        h1 { font-size: 1.1rem; font-weight: 400; }
        .instruction-highlight { font-weight: 600; color: #dfa668; }

        #puzzle-container { position: relative; z-index: 50; width: 90vw; max-width: 450px; margin-top: 15px; touch-action: none; }
        #puzzle-guide { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; opacity: 0.15; border: 1px dashed #ccc; border-radius: 8px; }
        #final-reveal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; opacity: 0; z-index: 150; transition: opacity 0.8s; border-radius: 8px; }

        .piece { position: absolute; z-index: 60; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3)); cursor: grab; }
        .piece.dragging { z-index: 1000; transform: scale(1.05); }
        .piece.locked { z-index: 40; filter: none; pointer-events: none; transition: all 0.2s ease-out; }

        #success-message { position: fixed; bottom: -300px; left: 50%; transform: translateX(-50%); background: white; padding: 25px; border-radius: 30px; box-shadow: 0 15px 50px rgba(0,0,0,0.3); text-align: center; opacity: 0; transition: all 0.6s cubic-bezier(0.17, 0.84, 0.44, 1); width: 85%; max-width: 350px; z-index: 2000; }
        #success-message.visible { bottom: 40px; opacity: 1; }
        .btn-form { display: inline-block; background-color: #dfa668; color: white; text-decoration: none; padding: 14px 24px; border-radius: 50px; font-weight: 600; margin-top: 15px; }
        
        .puzzle-complete .piece { display: none; }
        .puzzle-complete #final-reveal { opacity: 1; }
    </style>
</head>
<body>

    <div id="background-container"><img id="bg-img" src="bg.png"></div>

    <div id="game-ui">
        <h1>Assemblez les pi√®ces pour d√©couvrir<br><span class="instruction-highlight">la date du mariage</span></h1>
    </div>

    <div id="puzzle-container">
        <div id="puzzle-guide"></div>
        <div id="final-reveal"></div>
    </div>

    <div id="success-message">
        <h2>F√©licitations !</h2>
        <p>Vous connaissez la date et le lieu du mariage ü•∞</p>
        <a href="#" class="btn-form">Confirmer ma pr√©sence</a>
    </div>

    <script>
        const CONFIG = {
            piecesSrc: 'guide.jpg', 
            finalSrc: 'puzzle.png', 
            rows: 2, // R√©duit pour √©viter de couper les visages horizontalement
            cols: 3, 
            tabSizeFactor: 0.15,
            snapTolerance: 25 // Plus g√©n√©reux pour l'UX mobile
        };

        const container = document.getElementById('puzzle-container');
        const guide = document.getElementById('puzzle-guide');
        const finalReveal = document.getElementById('final-reveal');
        const successMsg = document.getElementById('success-message');

        let pieces = [];
        let lockedCount = 0;
        let img = new Image();

        img.onload = () => {
            const ratio = img.naturalWidth / img.naturalHeight;
            const containerWidth = container.offsetWidth;
            const containerHeight = containerWidth / ratio;
            container.style.height = containerHeight + 'px';
            
            guide.style.backgroundImage = `url(${img.src})`;
            finalReveal.style.backgroundImage = `url(${CONFIG.finalSrc})`;
            setupPuzzle();
        };
        img.src = CONFIG.piecesSrc;

        function setupPuzzle() {
            const w = container.offsetWidth;
            const h = container.offsetHeight;
            const pw = w / CONFIG.cols;
            const ph = h / CONFIG.rows;
            const tab = Math.min(pw, ph) * CONFIG.tabSizeFactor;

            // G√©n√©ration de formes d√©terministes pour √©viter les "accidents" visuels
            const shapes = [];
            for (let r = 0; r < CONFIG.rows; r++) {
                shapes[r] = [];
                for (let c = 0; c < CONFIG.cols; c++) {
                    shapes[r][c] = {
                        top: r > 0 ? -shapes[r-1][c].bottom : 0,
                        right: c < CONFIG.cols - 1 ? 1 : 0, // On force le "m√¢le" √† droite
                        bottom: r < CONFIG.rows - 1 ? 1 : 0, // On force le "m√¢le" en bas
                        left: c > 0 ? -shapes[r][c-1].right : 0
                    };
                }
            }

            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    createPiece(r, c, pw, ph, tab, shapes[r][c], w, h);
                }
            }
        }

        function createPiece(r, c, pw, ph, tab, shape, totalW, totalH) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const cw = pw + tab * 2;
            const ch = ph + tab * 2;
            
            canvas.width = cw;
            canvas.height = ch;
            canvas.className = 'piece';

            // Dessin de la pi√®ce
            ctx.beginPath();
            ctx.moveTo(tab, tab);
            drawSide(ctx, tab, tab, tab + pw, tab, shape.top, tab, true);
            drawSide(ctx, tab + pw, tab, tab + pw, tab + ph, shape.right, tab, false);
            drawSide(ctx, tab + pw, tab + ph, tab, tab + ph, shape.bottom, tab, true);
            drawSide(ctx, tab, tab + ph, tab, tab, shape.left, tab, false);
            ctx.closePath();

            ctx.save();
            ctx.clip();
            
            // Calcul du ratio d'affichage vs source
            const scaleX = img.naturalWidth / totalW;
            const scaleY = img.naturalHeight / totalH;
            
            const sx = (c * pw - tab) * scaleX;
            const sy = (r * ph - tab) * scaleY;
            const sw = cw * scaleX;
            const sh = ch * scaleY;

            ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);
            ctx.restore();

            // Effet de bordure plus doux
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Positionnement al√©atoire en bas de l'√©cran (zone de pioche)
            const rect = container.getBoundingClientRect();
            const startX = Math.random() * (window.innerWidth - cw);
            const startY = (window.innerHeight * 0.7) + (Math.random() * 50);
            
            canvas.style.width = cw + 'px';
            canvas.style.left = (startX - rect.left) + 'px';
            canvas.style.top = (startY - rect.top) + 'px';

            canvas.dataset.trX = (c * pw - tab);
            canvas.dataset.trY = (r * ph - tab);

            addEvents(canvas);
            container.appendChild(canvas);
            pieces.push(canvas);
        }

        function drawSide(ctx, x1, y1, x2, y2, type, tab, isHoriz) {
            if (type === 0) { ctx.lineTo(x2, y2); return; }
            const cx = (x1 + x2) / 2;
            const cy = (y1 + y2) / 2;
            const nx = isHoriz ? 0 : -type * tab;
            const ny = isHoriz ? type * tab : 0;
            
            ctx.quadraticCurveTo(cx + nx, cy + ny, x2, y2);
        }

        function addEvents(el) {
            let startX, startY, initialLeft, initialTop;
            
            const start = (e) => {
                const t = e.touches ? e.touches[0] : e;
                el.classList.add('dragging');
                startX = t.clientX;
                startY = t.clientY;
                initialLeft = parseFloat(el.style.left);
                initialTop = parseFloat(el.style.top);
                container.appendChild(el); 
            };

            const move = (e) => {
                if (!el.classList.contains('dragging')) return;
                e.preventDefault();
                const t = e.touches ? e.touches[0] : e;
                el.style.left = (initialLeft + (t.clientX - startX)) + 'px';
                el.style.top = (initialTop + (t.clientY - startY)) + 'px';
            };

            const end = () => {
                if (!el.classList.contains('dragging')) return;
                el.classList.remove('dragging');
                
                const curX = parseFloat(el.style.left);
                const curY = parseFloat(el.style.top);
                const tarX = parseFloat(el.dataset.trX);
                const tarY = parseFloat(el.dataset.trY);

                if (Math.hypot(curX - tarX, curY - tarY) < CONFIG.snapTolerance) {
                    el.style.left = tarX + 'px';
                    el.style.top = tarY + 'px';
                    el.classList.add('locked');
                    lockedCount++;
                    if (lockedCount === pieces.length) {
                        container.classList.add('puzzle-complete');
                        confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
                        setTimeout(() => successMsg.classList.add('visible'), 500);
                    }
                }
            };

            el.addEventListener('mousedown', start);
            el.addEventListener('touchstart', start, {passive: false});
            window.addEventListener('mousemove', move);
            window.addEventListener('touchmove', move, {passive: false});
            window.addEventListener('mouseup', end);
            window.addEventListener('touchend', end);
        }
    </script>
</body>
</html>
