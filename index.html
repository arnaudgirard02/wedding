<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Save the Date - Puzzle 3x3</title>
    <!-- Import de la librairie Canvas Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        /* --- RESET & BASE --- */
        * {
            box-sizing: border-box;
            /* Emp√™che la s√©lection de texte accidentelle */
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #f0f2f5; 
            color: #333;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden; /* Emp√™che le scroll de la page enti√®re pendant le jeu */
            position: relative;
            overscroll-behavior: none;
        }

        /* --- ARRI√àRE-PLAN --- */
        #background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; 
            z-index: 0;   
            pointer-events: none;
            overflow: hidden;
        }

        #bg-img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Remplit l'√©cran proprement */
            opacity: 0.15; /* L√©g√®re transparence pour ne pas g√™ner la vue */
            filter: blur(5px); /* Flou artistique pour le fond */
        }

        /* --- UI ELEMENTS --- */
        #game-ui {
            text-align: center;
            margin-bottom: 20px; 
            z-index: 50; 
            pointer-events: none;
            width: 90%;
            max-width: 600px;
            position: relative;
            padding-top: 20px;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 300;
            margin: 0;
            color: #2c3e50;
            transition: opacity 0.5s ease;
            text-shadow: 0 1px 0 rgba(255,255,255,0.8);
        }

        .instruction-highlight {
            font-weight: 700;
            color: #d35400;
        }

        /* --- PUZZLE CONTAINER --- */
        #puzzle-container {
            position: relative;
            z-index: 50; 
            width: 90vw; /* Largeur relative au viewport */
            max-width: 500px; /* Max pour desktop */
            /* L'aspect-ratio sera d√©fini par JS selon l'image */
            background-color: rgba(255, 255, 255, 0.5); 
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: background-color 0.5s, box-shadow 0.5s;
            touch-action: none; /* Indispensable pour le drag&drop mobile */
        }

        /* Le guide (image de fond att√©nu√©e) */
        #puzzle-guide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: 100% 100%;
            opacity: 0.2; 
            border: 2px dashed #ccc;
            border-radius: 8px;
            z-index: 0;
            pointer-events: none;
        }

        /* --- PIECES --- */
        .piece {
            position: absolute;
            cursor: grab;
            z-index: 60;
            /* Ombre port√©e l√©g√®re */
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            transition: transform 0.1s;
            touch-action: none; /* Indispensable sur chaque pi√®ce */
            -webkit-tap-highlight-color: transparent;
        }

        .piece.dragging {
            z-index: 1000 !important;
            cursor: grabbing;
            transform: scale(1.1);
            filter: drop-shadow(0 15px 30px rgba(0,0,0,0.3));
        }

        .piece.locked {
            z-index: 10 !important; /* En dessous des pi√®ces mouvantes */
            cursor: default;
            filter: none;
            transition: all 0.2s ease;
            pointer-events: none; /* Une fois plac√©e, on ne la bouge plus */
        }

        /* --- SUCCESS STATE --- */
        #success-message {
            position: absolute;
            bottom: -150px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 20px 30px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
            opacity: 0;
            transition: bottom 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.6s ease;
            width: 85%;
            max-width: 400px;
            z-index: 2000;
        }

        #success-message.visible {
            bottom: 40px;
            opacity: 1;
        }

        #success-message h2 {
            margin: 0 0 10px 0;
            color: #27ae60;
            font-size: 1.6rem;
        }

        #success-message p {
            margin: 0;
            color: #555;
            font-size: 1rem;
            line-height: 1.4;
        }

        /* Animation de fin : on rend le puzzle "propre" */
        .puzzle-complete .piece {
            filter: none !important;
            border: none;
        }
        
        .puzzle-complete #puzzle-guide {
            opacity: 0;
        }
        
        .puzzle-complete#puzzle-container {
            background-color: transparent;
            box-shadow: 0 20px 50px rgba(0,0,0,0.25);
            border: 2px solid #fff; /* Joli cadre blanc √† la fin */
        }

    </style>
</head>
<body>

    <!-- Fond d'√©cran d√©coratif -->
    <div id="background-container">
        <img id="bg-img" src="" alt="Background">
    </div>

    <!-- Interface Haut -->
    <div id="game-ui">
        <h1 id="instruction-text">Assemblez le puzzle pour<br><span class="instruction-highlight">d√©couvrir la date</span></h1>
    </div>

    <!-- Zone de jeu -->
    <div id="puzzle-container">
        <div id="puzzle-guide"></div>
        <!-- Les pi√®ces Canvas seront g√©n√©r√©es ici -->
    </div>

    <!-- Message de victoire -->
    <div id="success-message">
        <h2>F√©licitations ! üéâ</h2>
        <p>Rendez-vous le <strong>15 Juillet 2025</strong> !<br>H√¢te de vous y voir ‚ù§Ô∏è</p>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            imageSrc: 'puzzle.png', // L'image √† d√©couper
            guideSrc: 'guide.jpg',  // (Optionnel) Image de fond pour aider
            rows: 3,                // Config demand√© : 3
            cols: 3,                // Config demand√© : 3
            tabSizePercent: 24      // Taille des "oreilles" du puzzle
        };

        // --- √âL√âMENTS DOM ---
        const container = document.getElementById('puzzle-container');
        const guide = document.getElementById('puzzle-guide');
        const instructionText = document.getElementById('instruction-text');
        const successMsg = document.getElementById('success-message');

        // --- √âTAT DU JEU ---
        let pieces = [];
        let lockedCount = 0;
        const totalPieces = CONFIG.rows * CONFIG.cols;
        let piecesShapes = []; // Stockera les formes g√©n√©r√©es dynamiquement

        // --- CHARGEMENT IMAGE DE FOND (Fallback intelligent) ---
        const possibleBackgrounds = ['bg.jpg', 'background.jpg', 'bg.png', 'background.png'];
        const bgImgElement = document.getElementById('bg-img');
        
        function tryLoadBackground(index) {
            if (index >= possibleBackgrounds.length) return; // Aucun fond trouv√©, tant pis
            const imgPath = possibleBackgrounds[index];
            const tester = new Image();
            tester.onload = () => { bgImgElement.src = imgPath; };
            tester.onerror = () => { tryLoadBackground(index + 1); };
            tester.src = imgPath;
        }
        tryLoadBackground(0);

        // --- INIT PRINCIPAL ---
        const img = new Image();
        img.src = CONFIG.imageSrc;
        
        img.onload = () => {
            // Calcul du ratio pour le conteneur CSS
            const ratio = img.width / img.height;
            container.style.aspectRatio = `${ratio}`;
            
            // Configuration du guide
            guide.style.backgroundImage = `url('${CONFIG.imageSrc}')`; // On utilise la m√™me image par d√©faut

            initPuzzle();
        };

        img.onerror = () => {
            // Fallback visuel si pas d'image (cr√©ation d'un placeholder)
            const canvas = document.createElement('canvas');
            canvas.width = 600; canvas.height = 600;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "#3498db"; ctx.fillRect(0,0,600,600);
            ctx.fillStyle = "#fff"; ctx.font = "30px Arial"; ctx.textAlign = "center";
            ctx.fillText("Image 'puzzle.png' manquante", 300, 300);
            img.src = canvas.toDataURL();
        };

        function initPuzzle() {
            const basePieceW = img.width / CONFIG.cols;
            const basePieceH = img.height / CONFIG.rows;
            const tabSize = Math.min(basePieceW, basePieceH) * (CONFIG.tabSizePercent / 100);

            // G√©n√©ration dynamique des formes (tenons/mortaises)
            piecesShapes = generateJigsawShapes(CONFIG.rows, CONFIG.cols);

            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    const shapeIndex = r * CONFIG.cols + c;
                    createCanvasPiece(r, c, basePieceW, basePieceH, tabSize, piecesShapes[shapeIndex]);
                }
            }

            // On m√©lange les pi√®ces apr√®s un court d√©lai pour laisser l'interface s'afficher
            setTimeout(scramblePieces, 100);
        }

        // --- G√âN√âRATEUR DE FORMES DYNAMIQUE ---
        // 0 = plat (bord), 1 = tenon (sortant), -1 = mortaise (entrant)
        // Ordre : [Haut, Droite, Bas, Gauche]
        function generateJigsawShapes(rows, cols) {
            const shapes = [];
            // Init grille vide
            for (let i = 0; i < rows * cols; i++) shapes.push([0, 0, 0, 0]);

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const i = r * cols + c;

                    // Bordure Droite (si pas derni√®re colonne)
                    if (c < cols - 1) {
                        const type = Math.random() > 0.5 ? 1 : -1;
                        shapes[i][1] = type;           // Ma droite
                        shapes[i + 1][3] = -type;      // Gauche du voisin
                    }

                    // Bordure Bas (si pas derni√®re ligne)
                    if (r < rows - 1) {
                        const type = Math.random() > 0.5 ? 1 : -1;
                        shapes[i][2] = type;           // Mon bas
                        shapes[i + cols][0] = -type;   // Haut du voisin du dessous
                    }
                }
            }
            return shapes;
        }

        // --- CR√âATION GRAPHIQUE DES PI√àCES ---
        function createCanvasPiece(row, col, w, h, tabSize, shape) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // On ajoute de l'espace autour pour les "oreilles"
            const totalW = w + tabSize * 2;
            const totalH = h + tabSize * 2;
            
            canvas.width = totalW;
            canvas.height = totalH;
            canvas.classList.add('piece');

            ctx.save();
            ctx.beginPath();
            
            const offsetX = tabSize;
            const offsetY = tabSize;
            
            let x = offsetX;
            let y = offsetY;
            ctx.moveTo(x, y);

            // Tracer le contour avec les courbes de B√©zier
            // Haut
            if (shape[0] !== 0) drawTab(ctx, x, y, w, 0, shape[0] * tabSize);
            else ctx.lineTo(x + w, y);

            // Droite
            x += w;
            if (shape[1] !== 0) drawTab(ctx, x, y, 0, h, shape[1] * tabSize);
            else ctx.lineTo(x, y + h);

            // Bas
            y += h;
            if (shape[2] !== 0) drawTab(ctx, x, y, -w, 0, shape[2] * tabSize);
            else ctx.lineTo(x - w, y);

            // Gauche
            x -= w;
            if (shape[3] !== 0) drawTab(ctx, x, y, 0, -h, shape[3] * tabSize);
            else ctx.lineTo(x, y - h);

            ctx.closePath();
            ctx.clip(); // On d√©coupe la zone
            
            // Dessiner l'image source √† l'int√©rieur
            ctx.drawImage(img, 
                col * w - offsetX, row * h - offsetY,
                totalW, totalH,
                0, 0, totalW, totalH
            );
            
            // Bordure interne (reflet)
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Bordure externe (ombre)
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();

            // Mise √† l'√©chelle CSS pour que √ßa s'adapte √† l'√©cran
            // La largeur CSS est relative √† l'image source originale (pour garder les proportions)
            canvas.style.width = `${(totalW / img.width) * 100}%`;
            canvas.style.height = 'auto'; // Garde l'aspect ratio
            
            // On stocke la position cible en pourcentage (0 √† 100)
            const pctPerPixelX = 100 / img.width;
            const pctPerPixelY = 100 / img.height;
            
            canvas.dataset.targetX = (col * w - tabSize) * pctPerPixelX;
            canvas.dataset.targetY = (row * h - tabSize) * pctPerPixelY;

            addDragListeners(canvas);
            container.appendChild(canvas);
            pieces.push(canvas);
        }

        // Dessine une oreille (tab) de puzzle
        function drawTab(ctx, x, y, dx, dy, size) {
            const l = Math.sqrt(dx*dx + dy*dy);
            const neck = l * 0.35;
            
            const ux = dx / l;
            const uy = dy / l;
            const nx = -uy; 
            const ny = ux;

            const x1 = x + ux * (l - neck)/2;
            const y1 = y + uy * (l - neck)/2;
            
            const x2 = x + ux * (l + neck)/2;
            const y2 = y + uy * (l + neck)/2;

            ctx.lineTo(x1, y1);

            const h = Math.abs(size);
            const sign = size > 0 ? 1 : -1;
            
            const cx1 = x1 + nx * sign * h * 0.2;
            const cy1 = y1 + ny * sign * h * 0.2;
            
            const tx1 = x + ux * (l/2 - neck*0.5) + nx * sign * h;
            const ty1 = y + uy * (l/2 - neck*0.5) + ny * sign * h;
            
            const tx2 = x + ux * (l/2 + neck*0.5) + nx * sign * h;
            const ty2 = y + uy * (l/2 + neck*0.5) + ny * sign * h;
            
            const cx2 = x2 + nx * sign * h * 0.2;
            const cy2 = y2 + ny * sign * h * 0.2;

            ctx.bezierCurveTo(cx1, cy1, tx1, ty1, x + ux * l/2 + nx * sign * h, y + uy * l/2 + ny * sign * h);
            ctx.bezierCurveTo(tx2, ty2, cx2, cy2, x2, y2);
            
            ctx.lineTo(x + dx, y + dy);
        }

        // --- M√âLANGE ET DISPERSION ---
        function scramblePieces() {
            const containerRect = container.getBoundingClientRect();
            const winW = window.innerWidth;
            const winH = window.innerHeight;

            pieces.forEach(piece => {
                if(piece.classList.contains('locked')) return;
                
                // Position al√©atoire autour du puzzle ou par dessus
                // Sur mobile, on pr√©f√®re que ce soit "sur" le puzzle mais d√©cal√© pour ne pas perdre les pi√®ces hors √©cran
                const maxOffset = 50; // px
                
                // Calcul de limites s√ªres (viewport)
                const pieceW = piece.getBoundingClientRect().width;
                const pieceH = piece.getBoundingClientRect().height;

                // On g√©n√®re une position al√©atoire dans l'√©cran entier
                let randX = Math.random() * (winW - pieceW);
                let randY = Math.random() * (winH - pieceH);

                // Conversion en coordonn√©es relatives au conteneur (n√©cessaire car position: absolute dans le container)
                // Note : le container a 'position: relative', donc top/left 0 = coin haut gauche du container.
                // Si on veut mettre la pi√®ce en (100, 100) sur l'√©cran :
                // Left = 100 - container.left
                
                const relativeX = randX - containerRect.left;
                const relativeY = randY - containerRect.top;

                piece.style.left = `${relativeX}px`;
                piece.style.top = `${relativeY}px`;
            });
        }

        // --- DRAG & DROP (SOURIS + TOUCH) ---
        function addDragListeners(el) {
            let startX = 0, startY = 0;
            let initialLeft = 0, initialTop = 0;
            let isDragging = false;

            const onStart = (e) => {
                if (el.classList.contains('locked')) return;
                
                isDragging = true;
                el.classList.add('dragging');

                // Support souris ou tactile
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                startX = clientX;
                startY = clientY;
                
                // Position actuelle (calcul√©e depuis le style left/top qui peut √™tre en % ou px)
                initialLeft = el.offsetLeft;
                initialTop = el.offsetTop;
            };

            const onMove = (e) => {
                if (!isDragging) return;
                e.preventDefault(); // Emp√™che le scroll pendant qu'on tient une pi√®ce

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - startX;
                const deltaY = clientY - startY;

                el.style.left = `${initialLeft + deltaX}px`;
                el.style.top = `${initialTop + deltaY}px`;
            };

            const onEnd = () => {
                if (!isDragging) return;
                isDragging = false;
                el.classList.remove('dragging');
                checkSnap(el);
            };

            // √âv√©nements
            el.addEventListener('mousedown', onStart);
            el.addEventListener('touchstart', onStart, { passive: false });
            
            window.addEventListener('mousemove', onMove);
            window.addEventListener('touchmove', onMove, { passive: false });
            
            window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchend', onEnd);
        }

        // --- V√âRIFICATION POSITION (AIMANTATION) ---
        function checkSnap(el) {
            const containerW = container.offsetWidth;
            const containerH = container.offsetHeight;

            // Conversion position actuelle en %
            const currentX = (el.offsetLeft / containerW) * 100;
            const currentY = (el.offsetTop / containerH) * 100;

            const targetX = parseFloat(el.dataset.targetX);
            const targetY = parseFloat(el.dataset.targetY);

            // Distance euclidienne
            const dist = Math.sqrt(Math.pow(currentX - targetX, 2) + Math.pow(currentY - targetY, 2));
            
            // Tol√©rance : plus grande sur mobile pour faciliter
            const isMobile = window.innerWidth < 768;
            const threshold = isMobile ? 12 : 6; 

            if (dist < threshold) {
                snapPiece(el, targetX, targetY);
            }
        }

        function snapPiece(el, x, y) {
            // Force la position exacte
            el.style.left = `${x}%`;
            el.style.top = `${y}%`;
            
            el.classList.add('locked');
            
            // Petit son ou feedback visuel possible ici
            
            lockedCount++;
            if (lockedCount === totalPieces) onWin();
        }

        // --- VICTOIRE ---
        function onWin() {
            container.classList.add('puzzle-complete');
            
            // Masquer les instructions
            instructionText.style.opacity = '0';
            
            setTimeout(() => {
                successMsg.classList.add('visible');
                triggerConfetti();
                instructionText.style.display = 'none';
            }, 500);
        }

        // --- EFFET CONFETTI ---
        function triggerConfetti() {
            var duration = 3000;
            var end = Date.now() + duration;

            (function frame() {
                confetti({
                    particleCount: 5,
                    angle: 60,
                    spread: 55,
                    origin: { x: 0 },
                    colors: ['#ff7675', '#74b9ff', '#55efc4', '#ffeaa7']
                });
                confetti({
                    particleCount: 5,
                    angle: 120,
                    spread: 55,
                    origin: { x: 1 },
                    colors: ['#ff7675', '#74b9ff', '#55efc4', '#ffeaa7']
                });

                if (Date.now() < end) {
                    requestAnimationFrame(frame);
                }
            }());
        }
    </script>
</body>
</html>
