<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Save the Date - Puzzle</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        /* --- 1. RESET & BASE --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* EmpÃªche tout scroll global */
            background-color: #ffffff;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            touch-action: none; /* DÃ‰SACTIVE le scroll tactile sur tout l'Ã©cran pour le jeu */
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Utilise dvh pour s'adapter Ã  la barre d'adresse mobile dynamique */
            height: 100dvh; 
            position: relative;
        }

        /* --- 2. DÃ‰COR DE FOND (FIXE) --- */
        #background-layer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Tout au fond */
            pointer-events: none;
            display: flex;
            align-items: flex-end; /* Colle l'image en bas */
            justify-content: center;
        }

        #bg-img {
            display: block;
            width: 100%;
            height: auto;
            max-height: 45vh; /* Ne prend pas plus de 45% de la hauteur */
            object-fit: cover; /* S'assure de remplir la largeur */
            object-position: bottom center;
        }

        /* --- 3. UI (TITRE) --- */
        #ui-layer {
            position: relative;
            z-index: 10;
            margin-top: max(20px, env(safe-area-inset-top)); /* GÃ¨re l'encoche iPhone */
            text-align: center;
            width: 90%;
            flex-shrink: 0; /* Ne s'Ã©crase pas */
            padding-bottom: 10px;
        }

        h1 {
            font-size: clamp(1rem, 5vw, 1.4rem); /* Taille responsive */
            color: #444;
            font-weight: 400;
            margin: 0;
            line-height: 1.3;
            text-shadow: 0 1px 0 rgba(255,255,255,0.8);
        }
        
        .highlight { font-weight: 700; color: #dfa668; }

        /* --- 4. ZONE DE JEU (Flexible) --- */
        #game-wrapper {
            flex-grow: 1; /* Prend tout l'espace restant entre le titre et le bas */
            width: 100%;
            display: flex;
            align-items: flex-start; /* Aligne le puzzle vers le haut de la zone dispo */
            justify-content: center;
            position: relative;
            z-index: 20;
            padding-top: 10px;
            overflow: hidden; /* Les piÃ¨ces peuvent bouger dedans */
        }

        /* Le conteneur du puzzle lui-mÃªme */
        #puzzle-board {
            position: relative;
            /* Les dimensions seront forcÃ©es par JS pour respecter le ratio image */
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            background-color: rgba(255,255,255,0.2); /* LÃ©gÃ¨rement visible pour debug */
            border-radius: 4px;
            /* Transition fluide si on resize */
            transition: width 0.3s, height 0.3s;
        }

        /* Images internes (Guide et RÃ©vÃ©lation) */
        .puzzle-bg-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-size: 100% 100%; /* Force le remplissage exact */
            pointer-events: none;
            border-radius: 4px;
        }

        #guide-image {
            opacity: 0.25;
            z-index: 5;
            border: 1px dashed rgba(0,0,0,0.1);
        }

        #final-image {
            opacity: 0;
            z-index: 100; /* Passe devant tout Ã  la fin */
            transition: opacity 1s ease;
        }

        /* --- 5. PIÃˆCES --- */
        .piece {
            position: absolute;
            z-index: 50;
            cursor: grab;
            touch-action: none;
            /* Optimisation rendu mobile */
            transform-origin: center center;
            -webkit-tap-highlight-color: transparent;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
            transition: transform 0.1s;
        }

        .piece.dragging {
            z-index: 999;
            transform: scale(1.15);
            filter: drop-shadow(0 15px 30px rgba(0,0,0,0.3));
            cursor: grabbing;
        }

        .piece.locked {
            z-index: 10;
            pointer-events: none;
            transition: left 0.2s, top 0.2s;
            filter: none;
        }

        /* --- 6. MESSAGE VICTOIRE --- */
        #win-modal {
            position: fixed;
            bottom: -200px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 400px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
            z-index: 2000;
            opacity: 0;
            transition: bottom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s;
        }

        #win-modal.show {
            bottom: 30px;
            opacity: 1;
        }

        /* Ã‰tats de fin */
        body.finished #final-image { opacity: 1; }
        body.finished #guide-image { opacity: 0; }
        body.finished .piece { pointer-events: none; } /* On ne touche plus */
    </style>
</head>
<body>

    <div id="background-layer">
        <img id="bg-img" src="" alt="DÃ©cor">
    </div>

    <div id="ui-layer">
        <h1 id="title-text">Assemblez les piÃ¨ces pour dÃ©couvrir<br><span class="highlight">la date du mariage</span></h1>
    </div>

    <div id="game-wrapper">
        <div id="puzzle-board">
            <div id="guide-image" class="puzzle-bg-layer"></div>
            <div id="final-image" class="puzzle-bg-layer"></div>
            </div>
    </div>

    <div id="win-modal">
        <h2 style="margin:0 0 10px 0; color:#333;">FÃ©licitations ! ðŸŽ‰</h2>
        <p style="margin:0; color:#666;">Vous avez dÃ©couvert la date !<br>HÃ¢te de vous y voir.</p>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONF = {
            imgPuzzle: 'guide.jpg',   // Image sans texte
            imgFinal:  'puzzle.png',  // Image avec texte
            bgImage:   'bg.jpg',      // Fond
            rows: 3,
            cols: 4,
            snapDist: 20, // Distance d'aimantation en pixels (plus large pour mobile)
            tabSize: 0.2  // Taille des "oreilles" (20% de la piÃ¨ce)
        };

        // --- VARIABLES GLOBALES ---
        let pieces = [];
        let lockedCount = 0;
        let imgObj = null; // L'objet Image chargÃ©
        const board = document.getElementById('puzzle-board');
        const wrapper = document.getElementById('game-wrapper');

        // --- INITIALISATION ---
        function init() {
            // 1. Charger le fond
            const bgElement = document.getElementById('bg-img');
            bgElement.src = CONF.bgImage;
            bgElement.onerror = () => console.warn("Fond introuvable");

            // 2. Charger l'image du puzzle
            imgObj = new Image();
            imgObj.src = CONF.imgPuzzle;
            imgObj.onload = () => {
                // Configurer les images de fond CSS
                document.getElementById('guide-image').style.backgroundImage = `url('${CONF.imgPuzzle}')`;
                document.getElementById('final-image').style.backgroundImage = `url('${CONF.imgFinal}')`;
                
                // Calculer la taille et lancer
                resizeBoard();
                createPieces();
                scramble();
                
                // Ã‰couter le redimensionnement (rotation Ã©cran)
                window.addEventListener('resize', () => {
                    resizeBoard();
                    // On ne remÃ©lange pas, mais on pourrait vouloir repositionner les piÃ¨ces hors cadre
                });
            };
        }

        // --- CÅ’UR DU SYSTÃˆME RESPONSIVE ---
        function resizeBoard() {
            if (!imgObj) return;

            // Dimensions de l'image originale
            const naturalW = imgObj.width;
            const naturalH = imgObj.height;
            const imageRatio = naturalW / naturalH;

            // Espace disponible dans le wrapper (tient compte du header et footer visuels)
            // On prend 90% de la largeur et 80% de la hauteur dispo pour laisser de l'air
            const availW = wrapper.clientWidth * 0.95;
            const availH = wrapper.clientHeight * 0.90;

            let finalW, finalH;

            // Algorithme "contain" : faire rentrer le rectangle image dans le rectangle Ã©cran
            if (availW / imageRatio < availH) {
                // LimitÃ© par la largeur
                finalW = availW;
                finalH = availW / imageRatio;
            } else {
                // LimitÃ© par la hauteur
                finalH = availH;
                finalW = availH * imageRatio;
            }

            // Appliquer les dimensions exactes en pixels
            board.style.width = finalW + 'px';
            board.style.height = finalH + 'px';
            
            // Mettre Ã  jour la taille des piÃ¨ces existantes (si resize en cours de jeu)
            updatePiecesSize(finalW, finalH);
        }

        // --- CRÃ‰ATION DES PIÃˆCES ---
        function createPieces() {
            board.innerHTML = ''; // Reset
            board.appendChild(document.getElementById('guide-image'));
            board.appendChild(document.getElementById('final-image'));
            
            pieces = [];
            const shapes = generateShapes(); // GÃ©nÃ©rer les formes (trous/bosses)

            const wPerPiece = imgObj.width / CONF.cols;
            const hPerPiece = imgObj.height / CONF.rows;
            const tabPx = Math.min(wPerPiece, hPerPiece) * CONF.tabSize;

            for (let r = 0; r < CONF.rows; r++) {
                for (let c = 0; c < CONF.cols; c++) {
                    const canvas = document.createElement('canvas');
                    canvas.className = 'piece';
                    
                    // --- HAUTE RÃ‰SOLUTION (RETINA) ---
                    // On calcule la taille physique nÃ©cessaire pour inclure les oreilles
                    const rawW = wPerPiece + tabPx * 2;
                    const rawH = hPerPiece + tabPx * 2;
                    
                    // Canvas size (tampon interne)
                    canvas.width = rawW;
                    canvas.height = rawH;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // Dessiner la forme
                    ctx.save();
                    drawPuzzleShape(ctx, tabPx, tabPx, wPerPiece, hPerPiece, tabPx, shapes[r*CONF.cols + c]);
                    ctx.clip();
                    
                    // Dessiner l'image
                    ctx.drawImage(imgObj, 
                        c * wPerPiece - tabPx, r * hPerPiece - tabPx, // Source X, Y
                        rawW, rawH, // Source W, H
                        0, 0, rawW, rawH // Dest X, Y, W, H
                    );
                    ctx.restore();

                    // Contour lÃ©ger
                    ctx.save();
                    drawPuzzleShape(ctx, tabPx, tabPx, wPerPiece, hPerPiece, tabPx, shapes[r*CONF.cols + c]);
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.restore();

                    // --- STOCKAGE DES DONNÃ‰ES LOGIQUES ---
                    // On stocke la position cible en POURCENTAGE (indÃ©pendant des pixels)
                    canvas.dataset.targetLeftPct = ((c * wPerPiece - tabPx) / imgObj.width) * 100;
                    canvas.dataset.targetTopPct = ((r * hPerPiece - tabPx) / imgObj.height) * 100;
                    
                    // On stocke la largeur/hauteur en % pour le CSS
                    canvas.dataset.widthPct = (rawW / imgObj.width) * 100;
                    
                    // Attacher les Ã©vÃ©nements
                    addInteraction(canvas);
                    
                    board.appendChild(canvas);
                    pieces.push(canvas);
                }
            }
            // Appliquer la taille initiale
            updatePiecesSize(board.clientWidth, board.clientHeight);
        }

        // --- MISE Ã€ JOUR VISUELLE (RESIZE) ---
        function updatePiecesSize(boardW, boardH) {
            pieces.forEach(p => {
                // La largeur est relative au conteneur
                p.style.width = p.dataset.widthPct + '%';
                p.style.height = 'auto'; // Garde le ratio

                // Si la piÃ¨ce est verrouillÃ©e, on s'assure qu'elle reste bien placÃ©e
                if (p.classList.contains('locked')) {
                    p.style.left = p.dataset.targetLeftPct + '%';
                    p.style.top = p.dataset.targetTopPct + '%';
                }
            });
        }

        // --- GÃ‰NÃ‰RATION DES FORMES ---
        function generateShapes() {
            const s = [];
            for(let r=0; r<CONF.rows; r++) {
                for(let c=0; c<CONF.cols; c++) {
                    let top = 0, right = 0, bottom = 0, left = 0;
                    if(r > 0) top = -s[(r-1)*CONF.cols+c][2];
                    if(c < CONF.cols-1) right = Math.random() > 0.5 ? 1 : -1;
                    if(r < CONF.rows-1) bottom = Math.random() > 0.5 ? 1 : -1;
                    if(c > 0) left = -s[r*CONF.cols + (c-1)][1];
                    s.push([top, right, bottom, left]);
                }
            }
            return s;
        }

        function drawPuzzleShape(ctx, x, y, w, h, t, s) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            // Haut
            s[0]!==0 ? drawTab(ctx, x, y, w, 0, s[0]*t) : ctx.lineTo(x+w, y);
            // Droite
            x+=w; s[1]!==0 ? drawTab(ctx, x, y, 0, h, s[1]*t) : ctx.lineTo(x, y+h);
            // Bas
            y+=h; s[2]!==0 ? drawTab(ctx, x, y, -w, 0, s[2]*t) : ctx.lineTo(x-w, y);
            // Gauche
            x-=w; s[3]!==0 ? drawTab(ctx, x, y, 0, -h, s[3]*t) : ctx.lineTo(x, y-h);
            ctx.closePath();
        }

        function drawTab(ctx, x, y, dx, dy, sz) {
            const l = Math.sqrt(dx*dx + dy*dy), neck = l*0.35;
            const ux = dx/l, uy = dy/l, nx = -uy, ny = ux;
            const x1 = x + ux*(l-neck)/2, y1 = y + uy*(l-neck)/2;
            const x2 = x + ux*(l+neck)/2, y2 = y + uy*(l+neck)/2;
            const h = Math.abs(sz), s = sz>0 ? 1 : -1;
            
            ctx.lineTo(x1, y1);
            ctx.bezierCurveTo(x1+nx*s*h*0.2, y1+ny*s*h*0.2, x+ux*(l/2-neck/2)+nx*s*h, y+uy*(l/2-neck/2)+ny*s*h, x+ux*l/2+nx*s*h, y+uy*l/2+ny*s*h);
            ctx.bezierCurveTo(x+ux*(l/2+neck/2)+nx*s*h, y+uy*(l/2+neck/2)+ny*s*h, x2+nx*s*h*0.2, y2+ny*s*h*0.2, x2, y2);
            ctx.lineTo(x+dx, y+dy);
        }

        // --- MÃ‰LANGE (SCATTER) ---
        function scramble() {
            // On mÃ©lange en pixels RELATIFS au conteneur du puzzle
            // C'est la seule faÃ§on d'Ãªtre sÃ»r qu'elles sont "autour"
            
            // On dÃ©finit une zone "Autour du puzzle" qui dÃ©borde du board
            // Comme le wrapper a overflow: hidden, on reste dans l'Ã©cran
            const margin = 50; 
            const boundsW = wrapper.clientWidth - margin * 2;
            const boundsH = wrapper.clientHeight - margin * 2;
            
            // On doit calculer le dÃ©calage (offset) du board par rapport au wrapper
            const boardRect = board.getBoundingClientRect();
            const wrapRect = wrapper.getBoundingClientRect();
            const offsetLeft = boardRect.left - wrapRect.left;
            const offsetTop = boardRect.top - wrapRect.top;

            pieces.forEach(p => {
                // Position alÃ©atoire dans tout le wrapper
                const randX = Math.random() * boundsW; 
                const randY = Math.random() * boundsH;
                
                // On applique en position relative au BOARD
                // Donc si je veux Ãªtre Ã  gauche du board, j'ai une position nÃ©gative
                p.style.left = (randX - offsetLeft) + 'px';
                p.style.top = (randY - offsetTop) + 'px';
            });
        }

        // --- INTERACTION (UNIFIÃ‰E) ---
        function addInteraction(el) {
            let startX, startY, initialLeft, initialTop;
            
            const onDown = (e) => {
                if(el.classList.contains('locked') || document.body.classList.contains('finished')) return;
                e.preventDefault(); // Stop scroll
                
                el.classList.add('dragging');
                
                // Normaliser Touch/Mouse
                const ptr = e.touches ? e.touches[0] : e;
                startX = ptr.clientX;
                startY = ptr.clientY;
                
                // On lit les valeurs calculÃ©es actuelles (en pixels)
                initialLeft = parseFloat(el.style.left) || 0; // Attention : peut Ãªtre en % parfois, mais scramble met des px
                // Si c'est en %, on convertit en px pour le drag
                if(el.style.left.includes('%')) {
                    initialLeft = (parseFloat(el.style.left)/100) * board.clientWidth;
                    initialTop = (parseFloat(el.style.top)/100) * board.clientHeight;
                } else {
                    initialLeft = parseFloat(el.style.left);
                    initialTop = parseFloat(el.style.top);
                }
                
                // Mettre au premier plan
                el.style.zIndex = 1000;
            };

            const onMove = (e) => {
                if(!el.classList.contains('dragging')) return;
                e.preventDefault();
                
                const ptr = e.touches ? e.touches[0] : e;
                const dx = ptr.clientX - startX;
                const dy = ptr.clientY - startY;
                
                el.style.left = (initialLeft + dx) + 'px';
                el.style.top = (initialTop + dy) + 'px';
            };

            const onUp = () => {
                if(!el.classList.contains('dragging')) return;
                el.classList.remove('dragging');
                el.style.zIndex = '';
                checkSnap(el);
            };

            el.addEventListener('mousedown', onDown);
            el.addEventListener('touchstart', onDown, {passive: false});
            
            window.addEventListener('mousemove', onMove);
            window.addEventListener('touchmove', onMove, {passive: false});
            
            window.addEventListener('mouseup', onUp);
            window.addEventListener('touchend', onUp);
        }

        // --- VÃ‰RIFICATION (SNAP) ---
        function checkSnap(el) {
            // Position actuelle en px (relative au board)
            const curLeft = parseFloat(el.style.left);
            const curTop = parseFloat(el.style.top);
            
            // Position cible en px (calculÃ©e depuis les %)
            const targetLeft = (parseFloat(el.dataset.targetLeftPct) / 100) * board.clientWidth;
            const targetTop = (parseFloat(el.dataset.targetTopPct) / 100) * board.clientHeight;
            
            const dist = Math.sqrt(Math.pow(curLeft - targetLeft, 2) + Math.pow(curTop - targetTop, 2));

            if(dist < CONF.snapDist) {
                // Snap !
                el.style.left = el.dataset.targetLeftPct + '%';
                el.style.top = el.dataset.targetTopPct + '%';
                el.classList.add('locked');
                lockedCount++;
                if(lockedCount === pieces.length) victory();
            }
        }

        // --- VICTOIRE ---
        function victory() {
            document.body.classList.add('finished');
            document.getElementById('title-text').style.opacity = 0;
            document.getElementById('win-modal').classList.add('show');
            
            // Confettis
            const duration = 3000;
            const end = Date.now() + duration;
            (function frame() {
                confetti({ particleCount: 5, angle: 60, spread: 55, origin: { x: 0 } });
                confetti({ particleCount: 5, angle: 120, spread: 55, origin: { x: 1 } });
                if (Date.now() < end) requestAnimationFrame(frame);
            }());
        }

        // --- LANCEMENT ---
        init();

    </script>
</body>
</html>
