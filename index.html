<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Save the Date - Puzzle</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: #ffffff;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            touch-action: none;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #background-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 0;
            pointer-events: none;
        }

        #bg-img {
            display: block;
            width: 100%;
            height: auto;
        }

        #game-ui {
            text-align: center;
            padding: 15px 10px;
            z-index: 50;
        }

        h1 {
            font-size: 1.1rem;
            font-weight: 400;
            margin: 0;
            opacity: 0.8;
            color: #333;
            line-height: 1.4;
        }

        .instruction-highlight {
            font-weight: 600;
            color: #dfa668;
        }

        #puzzle-container {
            position: relative;
            z-index: 50;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            width: 320px;
            height: 240px;
        }

        @media (min-width: 500px) {
            #puzzle-container {
                width: 480px;
                height: 360px;
            }
        }

        @media (min-width: 700px) {
            #puzzle-container {
                width: 560px;
                height: 420px;
            }
        }

        #puzzle-guide {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: url('guide.jpg') no-repeat center/100% 100%;
            opacity: 0.25;
            border: 2px dashed #ccc;
            border-radius: 8px;
            z-index: 0;
            filter: blur(4px);
        }

        #final-reveal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: url('puzzle.png') no-repeat center/100% 100%;
            opacity: 0;
            z-index: 150;
            transition: opacity 1.5s ease-in-out;
            pointer-events: none;
            border-radius: 8px;
        }

        /* Pi√®ces en DIV avec background-image et clip-path */
        .piece {
            position: absolute;
            cursor: grab;
            z-index: 60;
            touch-action: none;
            background-image: url('guide.jpg');
            background-repeat: no-repeat;
            /* Le clip-path sera d√©fini inline */
        }

        .piece.dragging {
            z-index: 999;
            cursor: grabbing;
            filter: drop-shadow(0 8px 16px rgba(0,0,0,0.35));
        }

        .piece.locked {
            z-index: 100;
            cursor: default;
            pointer-events: none;
        }

        #success-message {
            position: fixed;
            bottom: -150px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 20px 25px;
            border-radius: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: calc(100% - 40px);
            max-width: 380px;
            z-index: 1000;
        }

        #success-message.visible {
            bottom: max(25px, env(safe-area-inset-bottom));
            opacity: 1;
        }

        #success-message h2 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.3rem;
        }

        #success-message p {
            margin: 0;
            color: #7f8c8d;
            font-size: 0.95rem;
        }

        .puzzle-complete #final-reveal { opacity: 1; }
        .puzzle-complete #puzzle-guide { opacity: 0; }
        .puzzle-complete .piece { opacity: 0; }
        .puzzle-complete { box-shadow: 0 15px 40px rgba(0,0,0,0.2); }
    </style>
</head>
<body>
    <div id="background-container">
        <img id="bg-img" src="bg.jpg" alt="">
    </div>

    <div id="game-ui">
        <h1>Assemblez les pi√®ces pour d√©couvrir<br><span class="instruction-highlight">la date du mariage</span></h1>
    </div>

    <div id="puzzle-container">
        <div id="puzzle-guide"></div>
        <div id="final-reveal"></div>
    </div>

    <div id="success-message">
        <h2>F√©licitations !</h2>
        <p>Vous avez maintenant la date du mariage ! H√¢te de vous y voir ü•∞</p>
    </div>

    <script>
        const CONFIG = {
            rows: 3,
            cols: 4,
            tabPercent: 0.18
        };

        const container = document.getElementById('puzzle-container');
        const successMsg = document.getElementById('success-message');

        let pieces = [];
        let piecesData = [];
        let lockedCount = 0;
        const totalPieces = CONFIG.rows * CONFIG.cols;

        // Formes des tabs (g√©n√©r√©es une fois)
        // 0 = bord plat, 1 = tab sortant, -1 = tab rentrant
        // [top, right, bottom, left]
        const shapes = generateShapes();

        function generateShapes() {
            const s = [];
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    let top = 0, right = 0, bottom = 0, left = 0;
                    if (r > 0) top = -s[(r-1) * CONFIG.cols + c][2];
                    if (c < CONFIG.cols - 1) right = Math.random() > 0.5 ? 1 : -1;
                    if (r < CONFIG.rows - 1) bottom = Math.random() > 0.5 ? 1 : -1;
                    if (c > 0) left = -s[r * CONFIG.cols + (c-1)][1];
                    s.push([top, right, bottom, left]);
                }
            }
            return s;
        }

        // Initialiser les donn√©es des pi√®ces
        for (let r = 0; r < CONFIG.rows; r++) {
            for (let c = 0; c < CONFIG.cols; c++) {
                piecesData.push({
                    row: r,
                    col: c,
                    shape: shapes[r * CONFIG.cols + c],
                    locked: false,
                    x: 0,
                    y: 0
                });
            }
        }

        // Cr√©er les pi√®ces
        createPieces();
        scramble();

        function createPieces() {
            pieces.forEach(p => p.remove());
            pieces = [];

            const cw = container.offsetWidth;
            const ch = container.offsetHeight;
            const pieceW = cw / CONFIG.cols;
            const pieceH = ch / CONFIG.rows;
            const tabSize = Math.min(pieceW, pieceH) * CONFIG.tabPercent;

            for (let i = 0; i < piecesData.length; i++) {
                const d = piecesData[i];
                const piece = document.createElement('div');
                piece.className = 'piece';
                if (d.locked) piece.classList.add('locked');

                // Taille de la pi√®ce (avec espace pour les tabs)
                const totalW = pieceW + tabSize * 2;
                const totalH = pieceH + tabSize * 2;

                piece.style.width = totalW + 'px';
                piece.style.height = totalH + 'px';

                // Position du background pour montrer la bonne partie de l'image
                const bgX = -(d.col * pieceW - tabSize);
                const bgY = -(d.row * pieceH - tabSize);
                piece.style.backgroundPosition = `${bgX}px ${bgY}px`;
                piece.style.backgroundSize = `${cw}px ${ch}px`;

                // G√©n√©rer le clip-path SVG pour la forme de la pi√®ce
                const clipPath = generateClipPath(d.shape, pieceW, pieceH, tabSize, totalW, totalH);
                piece.style.clipPath = clipPath;
                piece.style.webkitClipPath = clipPath;

                // Position
                if (d.locked) {
                    piece.style.left = (d.col * pieceW - tabSize) + 'px';
                    piece.style.top = (d.row * pieceH - tabSize) + 'px';
                } else {
                    piece.style.left = d.x + 'px';
                    piece.style.top = d.y + 'px';
                }

                piece.dataset.index = i;
                addDrag(piece, i, pieceW, pieceH, tabSize);
                container.appendChild(piece);
                pieces.push(piece);
            }
        }

        function generateClipPath(shape, pieceW, pieceH, tabSize, totalW, totalH) {
            const toPctX = (x) => (x / totalW * 100).toFixed(2);
            const toPctY = (y) => (y / totalH * 100).toFixed(2);

            // Fonction pour g√©n√©rer des points sur une courbe de B√©zier cubique
            function bezierPoints(p0, p1, p2, p3, numPoints) {
                const points = [];
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    const mt = 1 - t;
                    const mt2 = mt * mt;
                    const mt3 = mt2 * mt;

                    const x = mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x;
                    const y = mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y;
                    points.push({ x, y });
                }
                return points;
            }

            const pathPoints = [];
            let x = tabSize;
            let y = tabSize;

            // --- TOP EDGE ---
            if (shape[0] === 0) {
                pathPoints.push(`${toPctX(x)}% ${toPctY(y)}%`);
                pathPoints.push(`${toPctX(x + pieceW)}% ${toPctY(y)}%`);
            } else {
                const dir = shape[0];
                const tabH = tabSize;
                const neckW = pieceW * 0.28;
                const bulgeW = pieceW * 0.34;
                const centerX = x + pieceW / 2;
                const neckStart = centerX - neckW / 2;
                const neckEnd = centerX + neckW / 2;
                const tabTip = dir > 0 ? y - tabH : y + tabH;

                pathPoints.push(`${toPctX(x)}% ${toPctY(y)}%`);
                pathPoints.push(`${toPctX(neckStart)}% ${toPctY(y)}%`);

                // Courbe gauche du tab (neck vers bulge)
                const curve1 = bezierPoints(
                    { x: neckStart, y: y },
                    { x: neckStart, y: tabTip + (y - tabTip) * 0.4 },
                    { x: centerX - bulgeW / 2, y: tabTip },
                    { x: centerX, y: tabTip },
                    8
                );
                curve1.forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                // Courbe droite du tab (bulge vers neck)
                const curve2 = bezierPoints(
                    { x: centerX, y: tabTip },
                    { x: centerX + bulgeW / 2, y: tabTip },
                    { x: neckEnd, y: tabTip + (y - tabTip) * 0.4 },
                    { x: neckEnd, y: y },
                    8
                );
                curve2.slice(1).forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                pathPoints.push(`${toPctX(x + pieceW)}% ${toPctY(y)}%`);
            }
            x += pieceW;

            // --- RIGHT EDGE ---
            if (shape[1] === 0) {
                pathPoints.push(`${toPctX(x)}% ${toPctY(y + pieceH)}%`);
            } else {
                const dir = shape[1];
                const tabW = tabSize;
                const neckH = pieceH * 0.28;
                const bulgeH = pieceH * 0.34;
                const centerY = y + pieceH / 2;
                const neckStart = centerY - neckH / 2;
                const neckEnd = centerY + neckH / 2;
                const tabTip = dir > 0 ? x + tabW : x - tabW;

                pathPoints.push(`${toPctX(x)}% ${toPctY(neckStart)}%`);

                const curve1 = bezierPoints(
                    { x: x, y: neckStart },
                    { x: tabTip - (tabTip - x) * 0.4, y: neckStart },
                    { x: tabTip, y: centerY - bulgeH / 2 },
                    { x: tabTip, y: centerY },
                    8
                );
                curve1.forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                const curve2 = bezierPoints(
                    { x: tabTip, y: centerY },
                    { x: tabTip, y: centerY + bulgeH / 2 },
                    { x: tabTip - (tabTip - x) * 0.4, y: neckEnd },
                    { x: x, y: neckEnd },
                    8
                );
                curve2.slice(1).forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                pathPoints.push(`${toPctX(x)}% ${toPctY(y + pieceH)}%`);
            }
            y += pieceH;

            // --- BOTTOM EDGE ---
            if (shape[2] === 0) {
                pathPoints.push(`${toPctX(x - pieceW)}% ${toPctY(y)}%`);
            } else {
                const dir = shape[2];
                const tabH = tabSize;
                const neckW = pieceW * 0.28;
                const bulgeW = pieceW * 0.34;
                const centerX = x - pieceW / 2;
                const neckEnd = centerX + neckW / 2;
                const neckStart = centerX - neckW / 2;
                const tabTip = dir > 0 ? y + tabH : y - tabH;

                pathPoints.push(`${toPctX(neckEnd)}% ${toPctY(y)}%`);

                const curve1 = bezierPoints(
                    { x: neckEnd, y: y },
                    { x: neckEnd, y: tabTip - (tabTip - y) * 0.4 },
                    { x: centerX + bulgeW / 2, y: tabTip },
                    { x: centerX, y: tabTip },
                    8
                );
                curve1.forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                const curve2 = bezierPoints(
                    { x: centerX, y: tabTip },
                    { x: centerX - bulgeW / 2, y: tabTip },
                    { x: neckStart, y: tabTip - (tabTip - y) * 0.4 },
                    { x: neckStart, y: y },
                    8
                );
                curve2.slice(1).forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                pathPoints.push(`${toPctX(x - pieceW)}% ${toPctY(y)}%`);
            }
            x -= pieceW;

            // --- LEFT EDGE ---
            if (shape[3] === 0) {
                // Fermeture implicite
            } else {
                const dir = shape[3];
                const tabW = tabSize;
                const neckH = pieceH * 0.28;
                const bulgeH = pieceH * 0.34;
                const centerY = y - pieceH / 2;
                const neckEnd = centerY + neckH / 2;
                const neckStart = centerY - neckH / 2;
                const tabTip = dir > 0 ? x - tabW : x + tabW;

                pathPoints.push(`${toPctX(x)}% ${toPctY(neckEnd)}%`);

                const curve1 = bezierPoints(
                    { x: x, y: neckEnd },
                    { x: tabTip + (x - tabTip) * 0.4, y: neckEnd },
                    { x: tabTip, y: centerY + bulgeH / 2 },
                    { x: tabTip, y: centerY },
                    8
                );
                curve1.forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));

                const curve2 = bezierPoints(
                    { x: tabTip, y: centerY },
                    { x: tabTip, y: centerY - bulgeH / 2 },
                    { x: tabTip + (x - tabTip) * 0.4, y: neckStart },
                    { x: x, y: neckStart },
                    8
                );
                curve2.slice(1).forEach(p => pathPoints.push(`${toPctX(p.x)}% ${toPctY(p.y)}%`));
            }

            return `polygon(${pathPoints.join(', ')})`;
        }

        function scramble() {
            const rect = container.getBoundingClientRect();
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const header = document.getElementById('game-ui').offsetHeight + 10;

            pieces.forEach((p, i) => {
                if (piecesData[i].locked) return;

                const pw = p.offsetWidth, ph = p.offsetHeight;
                let x, y;

                const zones = [];

                // Bas
                if (winH - rect.bottom > ph + 30) {
                    zones.push(() => {
                        x = 10 + Math.random() * Math.max(0, winW - pw - 20);
                        y = rect.bottom + 10 + Math.random() * Math.max(0, winH - rect.bottom - ph - 20);
                    });
                }

                // Gauche
                if (rect.left > pw + 30) {
                    zones.push(() => {
                        x = 10 + Math.random() * Math.max(0, rect.left - pw - 20);
                        y = header + Math.random() * Math.max(0, winH - header - ph - 10);
                    });
                }

                // Droite
                if (winW - rect.right > pw + 30) {
                    zones.push(() => {
                        x = rect.right + 10 + Math.random() * Math.max(0, winW - rect.right - pw - 20);
                        y = header + Math.random() * Math.max(0, winH - header - ph - 10);
                    });
                }

                if (zones.length === 0) {
                    x = 10 + Math.random() * Math.max(0, winW - pw - 20);
                    y = header + Math.random() * Math.max(0, winH - header - ph - 20);
                } else {
                    zones[Math.floor(Math.random() * zones.length)]();
                }

                const relX = x - rect.left;
                const relY = y - rect.top;

                p.style.left = relX + 'px';
                p.style.top = relY + 'px';
                piecesData[i].x = relX;
                piecesData[i].y = relY;
            });
        }

        function addDrag(el, index, pieceW, pieceH, tabSize) {
            let startX, startY, initLeft, initTop;
            let dragging = false;

            const start = (e) => {
                if (piecesData[index].locked) return;
                e.preventDefault();
                dragging = true;
                el.classList.add('dragging');

                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;
                initLeft = el.offsetLeft;
                initTop = el.offsetTop;
            };

            const move = (e) => {
                if (!dragging) return;
                e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                el.style.left = (initLeft + touch.clientX - startX) + 'px';
                el.style.top = (initTop + touch.clientY - startY) + 'px';
            };

            const end = () => {
                if (!dragging) return;
                dragging = false;
                el.classList.remove('dragging');

                const d = piecesData[index];
                const targetX = d.col * pieceW - tabSize;
                const targetY = d.row * pieceH - tabSize;
                const curX = el.offsetLeft;
                const curY = el.offsetTop;

                const dist = Math.sqrt((curX-targetX)**2 + (curY-targetY)**2);
                const threshold = Math.max(25, pieceW * 0.3);

                if (dist < threshold) {
                    el.style.left = targetX + 'px';
                    el.style.top = targetY + 'px';
                    el.classList.add('locked');
                    d.locked = true;
                    lockedCount++;

                    if (lockedCount === totalPieces) win();
                } else {
                    d.x = el.offsetLeft;
                    d.y = el.offsetTop;
                }
            };

            el.addEventListener('mousedown', start);
            el.addEventListener('touchstart', start, {passive: false});
            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        function win() {
            container.classList.add('puzzle-complete');
            document.getElementById('game-ui').style.opacity = '0';

            setTimeout(() => {
                successMsg.classList.add('visible');
                confetti({
                    particleCount: 150,
                    spread: 70,
                    origin: { y: 0.9 },
                    colors: ['#ff718d', '#fdb44b', '#29cdff', '#e0c097']
                });
            }, 500);
        }

        // Resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                createPieces();
                scramble();
            }, 200);
        });

        // Emp√™cher zoom iOS
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#puzzle-container')) e.preventDefault();
        }, {passive: false});

        let lastTap = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) e.preventDefault();
            lastTap = now;
        }, {passive: false});
    </script>
</body>
</html>
